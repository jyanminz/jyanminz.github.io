<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++ Rvalue References Explained</title>
      <link href="/2023/04/28/C-Rvalue-References-Explained/"/>
      <url>/2023/04/28/C-Rvalue-References-Explained/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Rvalue-References-Explained"><a href="#C-Rvalue-References-Explained" class="headerlink" title="C++ Rvalue References Explained"></a><strong>C++ Rvalue References Explained</strong></h1><p>本文是对<a href="http://thbecker.net/articles/rvalue_references/section_01.html">Thomas Becker</a>的粗浅翻译，若有错误欢迎指出。</p><p>Rvalue references solve at least two problems:</p><ol><li>Implementing move semantics</li><li>Perfect forwarding</li></ol><h1 id="C-中的左值和右值"><a href="#C-中的左值和右值" class="headerlink" title="C++中的左值和右值"></a>C++中的左值和右值</h1><ol><li><p>早期在C中对lvalue和rvalue最初的定义如下：</p><ol><li><p>lvalue：一个出现在赋值符左边或者右边的expression（An <em>lvalue</em> is an expression <code>e</code> that may appear on the left or on the right hand side of an assignment）</p></li><li><p>rvalue：只出现在赋值符右边的expression（An <em>lvalue</em> is an expression <code>e</code>that may appear on the left or on the right hand side of an assignment）</p></li><li><p>举例来说：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a和b都是lvalues</span></span><br><span class="line">a = b;</span><br><span class="line">b = a;</span><br><span class="line">a = a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a * b是一个rvalue</span></span><br><span class="line"><span class="type">int</span> c = a * b;</span><br><span class="line">a * b = <span class="number">42</span><span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>在C++中，利用早期C中对于lvalue和rvalue的定义仍然有用，并且这种判断方法是一个intuitive的方法</p></li><li><p>但是在C++中，由用户定义的类型在modifiability和assignability中引入了一些微妙的变化，这些变化使得上述的定义变得不再准确。我们无需go further into this；下面是一个代替上述定义的定义，即使该定义存在一些争议，但会让读者更加容易理解rvalue references：</p><ol><li><p>lvalue即是一个expression，该expression refer to一个内存地址，并且允许我们通过&amp;来获取该内存地址的地址（An <em>lvalue</em> is an expression that refers to a memory location and allows us to take the address of that memory location via the <code>&amp;</code>operator）</p></li><li><p>rvalue即是一个expression，不是lvalue的就是rvalue（An <em>rvalue</em> is an expression that is not an lvalue）</p></li><li><p>举例来说</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lvalues:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">i = <span class="number">43</span>;<span class="comment">//i is a lvalue</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;<span class="comment">//i is a lvalue</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>() = <span class="number">42</span>;<span class="comment">//foo() is a lvalue</span></span><br><span class="line"><span class="type">int</span> *pl = &amp;<span class="built_in">foo</span>();<span class="comment">// foo() is a lvalue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rvalues:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">j = <span class="built_in">foobar</span>();<span class="comment">//foobar() is a rvalue</span></span><br><span class="line"><span class="type">int</span> *p2 = &amp;<span class="built_in">foobar</span>();<span class="comment">//error cannot take the address of a rvalue</span></span><br><span class="line">j = <span class="number">32</span>;<span class="comment">//32 is a rvalue</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>假设X是一个维护或者handle某些资源的类，比如说m_pResource；这里说的资源resource，作者指的是任何需要付出一定代价来construct（构建）、clone（克隆）、destruct（析构）的事物。</p><p>一个很好的例子是std::vector，一个vector在为其分配的内存中维护了一系列的对象objs。那么，逻辑上来说，对于X的copy assignment operator就会类似如下的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="type">const</span> &amp;rhs)&#123;</span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="comment">//make a clone of what ths.m_pResource refers to</span></span><br><span class="line"><span class="comment">//destruct the resource that m_pResouce refers to</span></span><br><span class="line"><span class="comment">//attach the clone to m_pResource</span></span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于X的copy constructor，类似于上述代码中的逻辑同样适用，假设X被如下使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// perhaps use x in various ways</span></span><br><span class="line">x = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><p>上述代码中的最后一行实际上完成了如下工作：</p><ul><li>从foo中返回的临时资源中clone</li><li>destruct x持有的资源并将其用clone来代替</li><li>destruct这个临时的资源并由此释放其资源</li></ul><p>显然，如果能够在x和临时资源之间通过**swap resource pointers(handles)**，接着令临时资源的destructor来destruct x的原始资源（to swap resource pointers (handles) between <code>x</code> and the temporary, and then let the temporary’s destructor destruct <code>x</code>‘s original resource），这样的方法更为有效。换一种方式来说，当在赋值符右边是一个rvalue的特殊情况下，我们希望copy assignment operator以如下的方式运作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [...]</span></span><br><span class="line"><span class="comment">// swap m_pResource and rhs.m_pResource</span></span><br><span class="line"><span class="comment">// [...]</span></span><br></pre></td></tr></table></figure><p>这被称为移动语义，在C++11中，这种conditional behavior可以通过一个重载来完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(&lt;mystery type&gt; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// [...]</span></span><br><span class="line">  <span class="comment">// swap this-&gt;m_pResource and rhs.m_pResource</span></span><br><span class="line">  <span class="comment">// [...]  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我们正在定义一个copy assignment operator的重载，上述代码中的mystery type必须是一个引用（we certainly want the right hand side to be passed to us by reference）</p><p>并且，我们期望mystery type具有如下的表现：</p><ol><li>当在一个使用普通引用和一个使用mystery type的两个重载中，rvalue选择mystery type的重载实现</li><li>而lvalues选择普通引用的重载实现</li></ol><p>此时，如果我们用rvalue reference来代替上述的mystery type，那么我们看到的就是关于rvalue reference的定义</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>如果X是一个任意的类型，那么X&amp;&amp;就是一个X的右值引用，为了更好的区分，普通的引用X&amp;又被称为左值引用</p><p>右值引用在很多方面与左值引用并无二致，但其在某些方面表现不同，其中最重要的就是在函数重载中，lvalue倾向于使用lvalue references，而rvalue倾向于使用rvalue references</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp; x)</span></span>; <span class="comment">// lvalue reference overload</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference overload</span></span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(x); <span class="comment">// argument is lvalue: calls foo(X&amp;)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">foobar</span>()); <span class="comment">// argument is rvalue: calls foo(X&amp;&amp;)</span></span><br></pre></td></tr></table></figure><p>故其主旨在于：</p><blockquote><p>Rvalue references allow a function to branch <strong>at compile time</strong> (via overload resolution) on the condition “Am I being called on an lvalue or an rvalue?”</p></blockquote><p>事实上，我们可以为任意函数重载一个使用rvalue references的定义，但是在绝大多数情况下，这种重载应该只发生在copy constructor以及assignment operator中，由此来实现移动语义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="type">const</span> &amp; rhs); <span class="comment">// classical implementation</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于copy constructor的右值引用重载来说，其实现与上述代码类似；</p><ul><li>注意：<ul><li>如果我们实现void foo(X &amp;)而没有实现void foo(X&amp;&amp;)，那么函数调用时没有发生变化：foo可以传入lvalues来调用，而不能通过传入rvalues来调用</li><li>如果我们实现void(X const &amp;)而没有实现void foo(X &amp;&amp;)，此时，foo可以通过传入lvalues和rvalues来调用，但是无法区分lvalues和rvalues，要想达到区分lvalues和rvalues的目的，必须实现void foo(X &amp;&amp;)</li><li>如果我们只实现void foo(X&amp;&amp;)而没有其他两个函数，那么根据C++11的最终版本，foo可以通过传入rvalues调用，但是如果传入一个lvalue将会触发编译错误</li></ul></li></ul><h1 id="Forcing-Move-Semantics"><a href="#Forcing-Move-Semantics" class="headerlink" title="Forcing Move Semantics"></a><strong>Forcing Move Semantics</strong></h1><p>C++11允许程序员在rvalues和lvalues上使用移动语义，一个很好的例子就是标准库函数中的swap；同样的，令X为一个重载了copy constructor和copy assignment operator的类，如此来完成在rvalues实现移动语义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>;</span><br><span class="line">  a = b; </span><br><span class="line">  b = tmp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">X a, b;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure><p>上述代码中没有rvalues，因此，swap函数的三行代码中使用non-move semantic，但是我们知道在如下场景可以使用移动语义：任何时候当一个variable成为copy construction或者copy assignment的源（source），这个variable不会再被使用或者称为一个assignment的目标（wherever a variable occurs as the source of a copy construction or assignment, that variable is either not used again at all, or else it is used only as the target of an assignment.）</p><p>C++11中，存在一个标准库函数std::move，这个函数用于将其参数转换为rvalue，在C++11中，标准库函数swap看起来就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">T <span class="title">tmp</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">  a = std::<span class="built_in">move</span>(b); </span><br><span class="line">  b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">X a, b;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure><p>如此一来，swap函数的三行代码中使用到了移动语义，对于没有实现移动语义的类型来说（即没有为其copy constructor和assignment operator重载右值引用的类型），这个新的swap的表现和老的swap一样。</p><p>使用std::move为我们带来了如下好处：</p><ol><li>对于哪些实现了移动语义的类型，许多标准的算法或者操作通过使用移动语义显著节省资源；一个很好的例子就是inplace sorting，在其中使用了大量的swap</li><li>STL经常需要特定类型具有copyability，即可成为容器元素的类型；但仔细审视，发现在大多数情况下，moveability已经足够。因此，我们可以使用具有moveability但非copyable的类型（如unique_pointer）</li></ol><p>既然我们已经知道了std::move的存在，我们就可以看出之前对copy assignment operator进行右值引用重载的方法存在一点问题。</p><p>考虑一个简单的变量赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b</span><br></pre></td></tr></table></figure><p>我们期望a持有的对象被一个b的拷贝取代，并且在这个取代的过程中，我们期望a之前持有的对象被析构，现在考虑下一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = std::<span class="built_in">move</span>(b);</span><br></pre></td></tr></table></figure><p>如果实现移动语义仅用于一个简单的swap，那么上述代码中发生的只是：a和b交换了资源，没有任何析构发生，a之前持有的对象肯定最终会被析构，但仅仅发生在b超过其作用域。除非，b成为了move的对象，这种情况下，a之前持有的对象会继续被pass。</p><p>因此，在我们考虑的copy assignment operator的实现中，我们不知道a之前持有的对象何时会被析构（Therefore, as far as the implementer of the copy assignment operator is concerned, it is not known when the object formerly held by <code>a</code> will be destructed）</p><p>这种放任a持有对象被析构的时间可能不会出现问题（如果the destruction of that object does not have any side effects that are visible to the outside world），但我们必须考虑到意外情况，比如说在析构函数中释放一个锁呢？因此，在右值引用的重载copy assignmentoperator中关于对象的析构必须显式被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform a cleanup that takes care of at least those parts of the</span></span><br><span class="line">  <span class="comment">// destructor that have side effects. Be sure to leave the object</span></span><br><span class="line">  <span class="comment">// in a destructible and assignable state.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Is-an-Rvalue-Reference-an-Rvalue"><a href="#Is-an-Rvalue-Reference-an-Rvalue" class="headerlink" title="Is an Rvalue Reference an Rvalue?"></a><strong>Is an Rvalue Reference an Rvalue?</strong></h1><p>和之前一样，令X为一个利用移动语义重载了其copy constructor和copy assignment operator的类；考虑如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X &amp;&amp; x)</span></span>&#123;</span><br><span class="line">X anotherX = x;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的问题是：在foo函数中，X的哪个版本的copy constructor会被调用？在这里，x是一个被声明为右值引用的变量，即，a reference which preferably and typically refers to an rvalue，因此，和x相关的函数调用应该和右值引用版本相关联，比如说<code>X(X&amp;&amp; rhs)</code>，换句话说，我们应该期待任何被声明为右值引用的东西本身应该是右值，右值引用的设计者应该考虑到一个细微的变化：</p><blockquote><p>任何被声明为右值引用的东西可以为lvalue或者rvalue，区分的标准是：如果这个东西有名字，那么其就是一个lvalue，否则其就是一个rvalue</p></blockquote><p>在上面的例子中，被声明为一个右值引用的东西有一个名称<code>x</code>，那么其就是一个<code>lvalue</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>&#123;</span><br><span class="line">X anotherX = x;<span class="comment">//calls X(X const &amp;rhs)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是一个被声明为右值引用而且没有名字，因此其是一个rvalue：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X&amp;&amp; <span class="title">goo</span><span class="params">()</span></span>;</span><br><span class="line">X x = <span class="built_in">goo</span>(); <span class="comment">// calls X(X&amp;&amp; rhs) because the thing on</span></span><br><span class="line">             <span class="comment">// the right hand side has no name</span></span><br></pre></td></tr></table></figure><p>这种设计背后的原因是：Allowing move semantics to be applied tacitly to something that has a name</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X anotherX = x;</span><br><span class="line"><span class="comment">// x is still in scope!</span></span><br></pre></td></tr></table></figure><p>像上述代码中的操作，是危险且容易招致错误的；因为我们已经移动过的东西在接下来的代码中仍然可以被访问，但是移动语义的全部要点就是：“在移动这个东西之后，dies and goes away”，因此上述规则：如果一个东西有名字，那么其就是一个左值，是合理的。</p><p>那么关于上述规则的另外一部分该如何理解呢？：如果一个东西没有名字，那么其是一个右值。</p><p>继续将目光投向上述的goo例子中，it is technically possible, though <strong>not very likely</strong>, that the expression <code>goo()</code> in the second line of the example refers to something that is still accessible after it has been moved from</p><p>但是回顾之前的section：这正是我们想要的，我们想要能够在左值上实现强制移动语义。那么这正是这条规则：如果一个obj没有名字，那么该obj就是一个右值，这条规则允许我们以可控的方式（controlled manner）实现强制移动语义，这也是std::move实现的原理（std::move将参数以引用形式引入，并没有在这个参数上进行任何的操作，然后其结果返回的类型就是一个右值引用）</p><p>该语句：std::move(x)被声明为一个右值引用而且并没有一个名字与其绑定，因此，其是一个右值。因此，std::move将其参数转换为一个右值，即使该参数本身不是一个右值。std::move实现的方式就是隐藏其名字。</p><p>下面的例子说明了“if-it-has-a-name rule”有多么重要，假设有一个基类Base，在这个基类中为copy constructor和assignment operator重载了移动语义的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Base</span>(Base <span class="type">const</span> &amp; rhs); <span class="comment">// non-move semantics</span></span><br><span class="line"><span class="built_in">Base</span>(Base&amp;&amp; rhs); <span class="comment">// move semantics</span></span><br></pre></td></tr></table></figure><p>现在假设我们在Base的基础上实现了一个Derived类，为了确保移动语义在Derived对象中的Base部分被应用，我们必须重载Derived类的copy constructor和assignment operator，其中copy assignment operator的操作与上面的类似，对于左值的版本是非常直观的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived <span class="type">const</span> &amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于右值的版本有一点细微的不同，当我们没有意识到“if-it-has-a-name rule”时，我们可能会写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived&amp;&amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(rhs) <span class="comment">// wrong: rhs is an lvalue</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d如果我们写出像上面一样的代码，Base类中的非移动版本的copy constructor将会被调用，因为rhs是有名字的！因此，其是一个左值，但我们期望的是调用Base中移动版本的copy constructor，那么我们必须写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived&amp;&amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(rhs)) <span class="comment">// good, calls Base(Base&amp;&amp; rhs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Move-Semantics-and-Compiler-Optimizations"><a href="#Move-Semantics-and-Compiler-Optimizations" class="headerlink" title="Move Semantics and Compiler Optimizations"></a><strong>Move Semantics and Compiler Optimizations</strong></h1><p>考虑如下的函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="comment">// perhaps do something to x</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d假设X是一个为copy constructor和copy assignment operator重载了移动语义版本的类，如果我们从字面意义上理解上述代码，我们或许会说，“等等，在x到foo的返回值这块存在一个value copy的动作，让我们考虑使用移动语义吧”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="comment">// perhaps do something to x</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(x); <span class="comment">// making it worse!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但不幸的是，上述代码将make things worse。任何现代编译器将对foo的原始版本进行一个返回值优化。换言之，与其在本地构建x然后将其复制出去，编译器会在foo的返回值处直接构建x对象，显而易见，这比使用移动语义要更好。</p><p>正如你所见，为了最好地使用右值引用和移动语义，我们需要理解并考虑到现代编译器所作出的特殊努力，正如返回值优化以及copy elision。这会使得事情变得微妙起来，但是，we chose C++ as our language of choice for a reason, right? We made our beds, so now let’s lie in them.</p><h1 id="Perfect-Forwarding-The-Problem"><a href="#Perfect-Forwarding-The-Problem" class="headerlink" title="Perfect Forwarding: The Problem"></a><strong>Perfect Forwarding: The Problem</strong></h1><p>考虑下面这个简单的工厂函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，该函数的意图是转发（forward）参数arg到T的构造函数中；理想来说，这个函数的工作方式应该就好像这个工厂函数并不存在，参数直接被转发到了构造函数中：即perfect forwarding。难过的是，上述代码完全不能胜任这个工作：其引入了一个新的面向值的调用（it introduces an extra call by value），当构造函数的参数为引用形式时，上述代码显得尤为拉跨。</p><p>最常见的解决方式是：选择如Boost::bind或者其他outer function，将参数修改为引用的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有些许改进，但是并非完美。现在问题变为：该工厂函数无法通过右值被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factory</span>&lt;X&gt;(<span class="built_in">hoo</span>()); <span class="comment">// error if hoo returns by value</span></span><br><span class="line"><span class="built_in">factory</span>&lt;X&gt;(<span class="number">41</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这可以通过将参数属性修改为const引用来改进：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg <span class="type">const</span> &amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在两个问题：</p><ol><li>如果factory并非只有一个，而是含有多个参数，我们必须提供不同参数所有non-const和const引用的组合数目个重载</li><li>这种转发并非完美，因为其避开了移动语义：在factory函数体中T的构造函数的参数是一个左值；因此，移动语义基本上不会发生（即使有可能没有这个包装函数，并且直接调用可能利用到移动语义）</li></ol><p>事实上，右值引用可以用来解决上述两个问题。右值引用为实现完美转发而不是使用非常多的重载成为可能。</p><h1 id="Perfect-Forwarding-The-Solution"><a href="#Perfect-Forwarding-The-Solution" class="headerlink" title="Perfect Forwarding: The Solution"></a><strong>Perfect Forwarding: The Solution</strong></h1><p>为了理解右值引用如何实现完美转发，我们需要先介绍两条新的关于右值引用的规则。</p><ol><li><p>记得在pre-11 C++中的语法规则中，我们无法在引用上取引用：类似于A&amp; &amp;这样的调用会造成编译错误，而C++11引入了如下的<code>**reference collapsing rules**</code>：</p><ol><li>A&amp; &amp; becomes A&amp;</li><li>A&amp; &amp;&amp; becomes A&amp;</li><li>A&amp;&amp; &amp; becomes A&amp;</li><li>A&amp;&amp; &amp;&amp; becomes A&amp;&amp;</li></ol></li><li><p>对于接收右值引用作为template argument的函数模板，存在一种特殊的模板参数推断规则：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p> 对于上述代码来说适用下列的规则：</p><ol><li>当foo在一个类型为<strong>A的左值</strong>上被调用，**T被解析为A&amp;**，从而根据reference collapsing rule，参数类型将变为A&amp;</li><li>当foo在一个类型为<strong>A的右值</strong>上被调用，<strong>T被解析为A</strong>，从而根据reference collapsing rule，参数类型将变为A&amp;&amp;</li></ol></li></ol><p>基于上述两条规则，我们现在可以适用右值引用来解决之前提到的完美转发的问题，解决方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Arg&gt;(arg)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的std::forward定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> S&gt;</span></span><br><span class="line"><span class="function">S&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;S&gt;::type&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;S&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将从左值和右值两个方面来探讨上面的代码如何实现完美转发，令A和X为不同的类型。</p><p>首先假设，factory<A>在一个类型为X 的左值上被调用：</A></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line"><span class="built_in">factory</span>&lt;A&gt;(x);</span><br></pre></td></tr></table></figure><p>接着，基于special template deduction规则，factory的模板参数Arg被解析为X&amp;，因此，编译器会为factory和std::forward创建如下的实例（instantiation）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp; &amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&amp;&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp; &amp;&amp; <span class="title">forward</span><span class="params">(remove_reference&lt;X&amp;&gt;::type&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp; &amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在evaluate remove_reference和应用reference collapsing规则之后，上述代码将变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&amp;&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp; <span class="title">std::forward</span><span class="params">(X&amp; a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是对于左值的完美转发，factory的参数arg通过两层indirection传入到A的构造器中，两层都是通过old-fashioned左值引用</p><p>接下来，假设factory<A>在类型为X的右值上被调用：</A></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">factory</span>&lt;A&gt;(<span class="built_in">foo</span>());</span><br></pre></td></tr></table></figure><p>类似的，通过special template deduction规则，factory的模板参数Arg被解析为X。由此，编译器会创建如下的两个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp;&amp; <span class="title">forward</span><span class="params">(X&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是右值的完美转发：factory的参数经过两层转发最终传入到A的构造器中，两层转发都是经过引用。而且，A的构造器看到的参数是一个右值引用而且并没有和一个名字绑定（does not have a name），基于no-name规则，这样的东西是一个右值。因此，A的构造器将通过一个右值来调用。这意味着转发保留了所有的移动语义，就像factory wrapper不存在时一样。</p><p>值得提一嘴的是，std::forward存在的唯一目的就是为了保留移动语义（the preservation of move semantics is in fact the <em>only</em> purpose of <code>std::forward</code> in this context）如果不使用std::forward，除了A的构造器将永远将其参数视为一个有名字的左值，函数其他功能还是能够正常的工作。</p><p>另一种说法是std::forward的目的就是：to forward the information whether at the call site, the wrapper saw an lvalue or an rvalue.</p><p>如果想要再深挖一点，问问自己这个问题：在std::forward的定义中，remove_reference为何会存在？答案是：remove_reference可以不被需要，如果我们在std::forward定义中使用S&amp;而不是remove_reference<S>::type&amp;，我们可以得到上述一样的结果。但是，<strong>只有当我们显式地specify Arg作为std::forwad的模板参数才能达到上述结果</strong>。remove_reference的目的就在于强迫我们这样做。</S></p><p>高兴的是，我们就快结束了。剩下的仅是看看std::move的实现。记住，std::move的目的在于：pass its argument right through by reference and make it bind like an rvalue</p><p>下面是std::move的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">std::move</span><span class="params">(T&amp;&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; RvalRef;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;RvalRef&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们通过类型为X的左值调用std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">std::<span class="built_in">move</span>(x);</span><br></pre></td></tr></table></figure><p>基于special template deduction规则，模板参数T将会被解析为X&amp;，因此，编译器会生成如下实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;X&amp;&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">std::move</span><span class="params">(X&amp; &amp;&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;X&amp;&gt;::type&amp;&amp; RvalRef;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;RvalRef&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用remove_reference和reference collapsing规则之后，上述代码将变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X&amp;&amp; <span class="title">std::move</span><span class="params">(X&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>S上述代码完成了如下任务：左值x将会与左值引用绑定作为其参数类型（our lvalue <code>x</code> will bind to the lvalue reference that is the argument type），函数将这个参数pass right through，将其转换为一个没有名字的右值引用。</p><h1 id="Rvalue-References-And-Exceptions"><a href="#Rvalue-References-And-Exceptions" class="headerlink" title="Rvalue References And Exceptions"></a><strong>Rvalue References And Exceptions</strong></h1><p>正常来说，当你正在开发一款基于C++的应用，是否关注程序的异常安全性完全取决于你的选择。右值引用在异常安全的语境下又存在一些不同，当你想要利用移动语义重载一个类中的copy assignment operator和copy constructor，下面几件工作是非常建议你完成的：</p><ol><li>尽量写出不抛出异常的重载代码</li><li>如果能够写出不抛出异常的代码，接下来就使用nonexcept关键字</li></ol><p>如果你没有完成上述两件工作，那么至少存在一个非常常见的场景，该场景下移动语义不会生效（尽管你非常期望移动语义能够生效）：当std::vector进行resize时，你当然希望vector中现存的元素被relocate进新的内存块时使用移动语义，但是如果上述两个条件没有满足，这种事情不会发生。</p><h1 id="The-Case-of-the-Implicit-Move"><a href="#The-Case-of-the-Implicit-Move" class="headerlink" title="The Case of the Implicit Move"></a><strong>The Case of the Implicit Move</strong></h1><p>当用户没有提供为右值引用重载的拷贝构造函数或者重载赋值操作符时，编译器将implicitly生成这两个重载的函数。这将导致一些问题，具体参见：<a href="http://thbecker.net/articles/rvalue_references/section_10.html">http://thbecker.net/articles/rvalue_references&#x2F;section_10.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU15445 PROJECT1 BUFFER POOL</title>
      <link href="/2023/04/17/CMU15445-PROJECT-1-BUFFER-POOL/"/>
      <url>/2023/04/17/CMU15445-PROJECT-1-BUFFER-POOL/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-1-Buffer-Pool"><a href="#Project-1-Buffer-Pool" class="headerlink" title="Project#1-Buffer Pool"></a>Project#1-Buffer Pool</h1><p>project1要求实现一个线程安全的缓冲池，该缓冲池用于在内存和磁盘中实现数据页的来回移动，缓冲池的存在允许DBMS管理大小大于系统中可用内存的数据库。并且，缓冲池的各种操作对于数据库系统的其他部分是透明的。</p><p>下文首先对完成proj1必要的背景知识进行介绍，随之介绍各子任务的实现细节。</p><h1 id="一、Buffer-Manager"><a href="#一、Buffer-Manager" class="headerlink" title="一、Buffer Manager"></a>一、Buffer Manager</h1><p>首先，缓冲池就是在系统内存中开辟的一块用于保存磁盘数据副本的空间，这些副本较于磁盘数据往往更加“新”（被修改过）或者和磁盘数据一致，被修改过的内存数据之后会被写入磁盘中。</p><p>由于数据库的数据想要被读取或者被更新，首先要被读入系统内存中，因为磁盘访问速度远远小于内存的访问速度以及将数据库所有数据全部加载进内存是不可能的。当某线程想要访问数据库中的某个数据块时，如何减少磁盘的直接访问从而提高访问效率是一个值得探讨的问题。</p><p>缓冲池管理器(buffer pool manager)的存在就是为了最大化当线程想要访问某一数据块时，该数据块在内存中而不是磁盘中的概率，即减少对磁盘的直接访问。当某一线程对BPM发送对磁盘中的某数据块的请求：</p><ol><li>如果该数据块在缓冲池中，那么BPM将返回该数据块在内存中的地址。</li><li>如果该数据块不在缓冲池中，那么BPM首先在缓冲池中为该数据块分配相应大小的空间，这里又可以分为两个情况：<ol><li>缓冲池中空余空间大于数据块需要的空间，那么直接分配即可；</li><li>缓冲池中空余空间小于数据块需要的空间，那么BPM首先会驱逐池中的某些数据块，再进行空间的分配。如果这些数据块在加载进缓冲池中后被修改过，那么在驱逐它们之前需要将这些数据重写回磁盘。</li></ol></li></ol><p>可以看到BPM扮演的角色和虚拟内存管理器(Virtual memory manager)比较相似，但是相较于VMM，BPM的实现使用了更加精细复杂的技巧。</p><h1 id="二、Buffer-replacement-strategy"><a href="#二、Buffer-replacement-strategy" class="headerlink" title="二、Buffer replacement strategy"></a>二、Buffer replacement strategy</h1><p>当内存中没有剩余空间为新的数据块请求分配时，现存于缓冲池的某些数据块必须被驱逐，大多数操作系统使用LRU来管理数据块的驱逐。在对数据块进行驱逐出和写进来缓冲池时，需要注意以下几个方法的实现：</p><h3 id="2-1-pinned-blocks"><a href="#2-1-pinned-blocks" class="headerlink" title="2.1 pinned blocks"></a>2.1 pinned blocks</h3><p>当一个数据块被放入缓冲池后，而此时某一线程正在读取或者写入该数据页，如果这时有其他的线程将该数据块驱逐出缓冲池并且在该地址替换了一个新的数据页，这必然会出现问题。</p><p>那么为了保证正在被使用的数据页不被驱逐，就需要对该数据页打上一个标记，也就是子标题的pin这个数据页。当线程在某个数据页上执行pin操作，这个数据页在结束线程对其访问之前不会被驱逐。当线程执行完对该数据页的操作时，线程应当在该数据页上执行unpin操作，表明自己已经结束对该数据页的使用，同时表明该数据页此时可以被驱逐。</p><p>在多线程环境下，可能有多个线程对同一个数据页进行访问，那么只有当所有线程都结束了对该数据页的访问时，该数据页才能被驱逐。一个简单的实现是对缓冲池中的每一个数据页都维护一个pin_count的变量：</p><ol><li>当数据页被pin时，pin_count+1；</li><li>当数据页被unpin时，pin_count-1；</li><li>当pin_count为0时，表明其可以被驱逐出缓冲池。</li></ol><h3 id="2-2-shared-and-exclusive-locks-on-buffer"><a href="#2-2-shared-and-exclusive-locks-on-buffer" class="headerlink" title="2.2 shared and exclusive locks on buffer"></a>2.2 shared and exclusive locks on buffer</h3><p>BMP允许线程在缓冲池中拿到共享或独占锁。即当线程在某个数据页上执行变更其内容的操作时，其他线程是不能访问该数据页的内容的。其中对于上锁有如下规定：</p><ol><li>共享锁在同一时间可以被多个线程获取；</li><li>独占锁在某一时间只有一个线程能够被获取，在数据页被加上独占锁后，是不能够再加共享锁的；</li><li>当数据页被加上独占锁a或者共享锁a后，如果其余线程想要获取该数据页的独占锁b，必须等待独占锁a&#x2F;共享锁a解锁；</li><li>当数据页被加上独占锁，对该页共享锁的申请页必须等待。</li></ol><p>获取锁和释放锁的规定：</p><ol><li>当线程对某一数据页执行任何操作时，线程必须执行pin操作而后上锁，在结束对该数据页的操作后，先释放锁而后执行unpin操作；</li><li>在读取缓冲池中数据页之前，线程必须获得该数据页的共享锁，完成读取后释放之；</li><li>在更新数据页内容之前，线程必须获取该数据页的独占锁，当更新操作完成之后必须释放之。</li></ol><h1 id="三、PROJECT-1-BUFFER-POOL"><a href="#三、PROJECT-1-BUFFER-POOL" class="headerlink" title="三、PROJECT #1 - BUFFER POOL"></a>三、PROJECT #1 - BUFFER POOL</h1><h3 id="3-1-TASK-1-LRU-REPLACEMENT-POLICY"><a href="#3-1-TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="3.1 TASK #1 - LRU REPLACEMENT POLICY"></a>3.1 <strong><strong>TASK #1 - LRU REPLACEMENT POLICY</strong></strong></h3><p>该部分负责追踪缓冲池中页面使用的情况，主要实现lru_replacer.h中LRUReplacer类中的四个接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUReplacer</span> : <span class="keyword">public</span> Replacer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LRUReplacer</span><span class="params">(<span class="type">size_t</span> num_pages)</span></span>;</span><br><span class="line">  ~<span class="built_in">LRUReplacer</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; _data_idx;</span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; _data;</span><br><span class="line">  std::mutex _latch;</span><br><span class="line">  <span class="type">size_t</span> _max_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中关键实现逻辑如下：</p><ol><li>Pin表示当前有线程正在访问该frame，如何确保该frame不被驱逐，最简单的方式就是将其从replacer中移除；</li><li>Unpin表示没有线程在访问该frame，表示这个frame可以成为Victim并且被驱逐，将这个frame放入replacer中即可；</li><li>Victim表示移除replacer中最不常使用的页面，其参数是一个传出参数，用于保存被驱逐出的页面的信息，当replacer为空时返回false；</li><li>LRU的实现逻辑就是：_data和_data_idx保存的是最不常被访问的数据页，当有数据页被Pin即被访问，就将其驱逐出replacer中；当数据页被Unpin，表明没有线程方位该数据页，那么就将该frame加入链表的末尾；可以看到，这样的实现保证了最不常被访问（即停留在_data链表中最久）的数据页id在链表头部，所以Victim一个数据页时就将_data头部的数据驱逐出链表即可。</li><li>注意在各种操作之前加锁；</li></ol><h3 id="3-2-TASK-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#3-2-TASK-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="3.2 TASK #2 - BUFFER POOL MANAGER INSTANCE"></a>3.2 <strong><strong>TASK #2 - BUFFER POOL MANAGER INSTANCE</strong></strong></h3><p>BufferPoolManagerInstance负责从DiskManager中提取页，并将其放入内存中。BPMI还可以将脏页写回磁盘、驱逐一个页以为新页挪出空间。该task主要实现buffer_pool_manager_instance.h中的接口，该类的主要数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page *pages_; <span class="comment">//一个page数组用于保存缓冲池中的page</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_; <span class="comment">//用于管理缓冲池中的page，实现page_id到frame_id的映射</span></span><br><span class="line">Replacer *replacer_; <span class="comment">//用于找到unpined数据页</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_; <span class="comment">//没有使用的page</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>其中frame_id就是page_id在缓冲池中的一个表现形式，数据页在DiskManager中使用page_id来管理，当被放入缓冲池中，就用frame_id来管理。bufferPool中已经对其维护的page数组进行了初始化，其后的操作都只是修改page的元数据和数据而不是消除或者新建一个page对象。我认为对frame_id和page_id的理解是完成该task的关键所在。</p><ol><li>在Page类中主要维护了pin_count用于追踪正在访问该页线程的个数、is_dirty_记录自页面放入内存池中有未被修改、page_id_时DiskManager中该页面的id，如果该页面不包含physical page则设置其为INVALID_PAGE_ID</li><li>DiskManager主要实现了将数据写入磁盘和从磁盘读取数据的一些接口。</li></ol><p><img src="/.com//Untitled.png" alt="test"></p><p>以下是BufferPoolManagerInstance中各接口的关键实现逻辑：</p><ol><li><code>FlushPgImp</code>：刷新缓冲区的指定页到磁盘中，首先检查page_table_中是否有该页，没有返回false；有则记得先将page中is_dirty_设置为false，随后调用disk_manager的函数将数据页写回到磁盘中；</li><li><code>FlushAllPgImp</code>：将每个页都写回到磁盘中；</li><li><code>NewImp</code>：在缓冲池中新建一个页<ol><li>首先检查缓冲池中的所有数据页是否都正在被使用，是则返回nullptr；</li><li>完成上述检查：首先检查free_list，free_list为空就使用replacer进行数据页的驱逐，如果二者皆失败则返回nullptr。</li><li>拿到数据页后记得检查该页是否为脏页，是则先将其写回磁盘。</li><li>接着就是将该数据页纳入page_table_的管理（这里page_id的设置有些绕，确保在page_table_中的page_id是最新的page_id）</li><li>最后记得pin该数据页；</li></ol></li><li><code>FetchPgImp</code>：获取指定数据页<ol><li>如果要fetch的数据页已经在缓冲池中，取出就好，记得将pin_count加一；</li><li>如果指定数据页不在缓冲池中，则先将该页从磁盘读入内存中，读入的过程也是先检查free_list是否有空余位置，没有再用replacer驱逐页。</li><li>拿到数据页后更新page_table_和pages中的信息以及pin该数据页</li></ol></li><li><code>UnpinPgImp</code>：用户向缓冲池通知页面使用完毕的接口<ol><li>实现上注意检查page的pin_count，pin_count为0时从replacer中unpin该page</li><li>注意在replacer和BMPI中pin&#x2F;unpin操作含义的不同：在replacer中pin一个page表示该page应该从replacer中被驱逐，而在BMPI中pin一个page表示该页正在被使用，其不能被驱逐出缓冲池。</li></ol></li></ol><h3 id="3-3-TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#3-3-TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="3.3 TASK #3 - PARALLEL BUFFER POOL MANAGER"></a>3.3 <strong><strong>TASK #3 - PARALLEL BUFFER POOL MANAGER</strong></strong></h3><p><code>ParallelBufferPoolManager</code>中维护了多个<code>BufferPoolManagerInstance</code>，对于每个操作，PBPM会挑选一个BPMI来完成相应任务。</p><p>在实现中使用给定的<code>page_id</code>来决定选取特定的BPMI来完成任务。比如说一共有<code>num_instances</code>个BPMI，那我们就需要将给定的page_id映射到<code>[0, num_instances)</code>这个范围中来，在该project中使用了mod算子来完成这个映射任务：<code>page_id mod num_instances</code></p><p>ParallelBufferPoolManager类中维护的关键数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelBufferPoolManager</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                            LogManager *log_manager = <span class="literal">nullptr</span>);</span><br><span class="line">  ~<span class="built_in">ParallelBufferPoolManager</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">BufferPoolManager *<span class="title">GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line">  <span class="function">Page *<span class="title">FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Page *<span class="title">NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;BufferPoolManager *&gt; instances_;</span><br><span class="line">  <span class="type">size_t</span> start_idx_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">size_t</span> num_instances_;</span><br><span class="line">  <span class="type">size_t</span> pool_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意用于维护多个缓冲池的数据结构instances_中存放的是缓冲池实现类的基指针，接下来调用的函数应该为缓冲池实现类的基类对应的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager, LogManager *log_manager) : <span class="built_in">num_instances_</span>(num_instances), <span class="built_in">pool_size_</span>(pool_size)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++)&#123;</span><br><span class="line">    BufferPoolManagerInstance *temp = <span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager);</span><br><span class="line">    instances_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是ParallelBufferPoolManager中各接口的关键实现逻辑：</p><ol><li><code>GetBufferPoolManager</code>：<ol><li>从instances_中取出一个BPMI，下标就是用mod算子将给定page_id映射到<code>[0, num_instances_)</code>中的某个数字</li></ol></li><li><code>FetchPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的FetchPage方法</li></ol></li><li><code>UnpinPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的UnpinPage方法</li></ol></li><li><code>FlushPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的FlushPage方法</li></ol></li><li><code>NewPgImp</code>：<ol><li>从start_idx开始，不停轮询instances中的各BMPI，看能否申请到一个新页</li><li>如果成功申请到新页，更新start_idx的值为申请到页面的下一个页面对应的BMPI的index，并返回指向该页的指针</li><li>未能成功申请到page时返回nullptr，start_idx加一</li></ol></li><li><code>DeletePgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的DeletePgImp方法</li></ol></li><li><code>FlushAllPagesImpl</code>：<ol><li>对于instances_中维护的每一个BMPI，都调用FlushAllPages方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> course projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cheatsheet</title>
      <link href="/2023/04/08/Redis-Cheatsheet/"/>
      <url>/2023/04/08/Redis-Cheatsheet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2023/04/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/04/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis三种数据持久化方式"><a href="#Redis三种数据持久化方式" class="headerlink" title="Redis三种数据持久化方式"></a>Redis三种数据持久化方式</h1><h1 id="一、AOF日志"><a href="#一、AOF日志" class="headerlink" title="一、AOF日志"></a>一、AOF日志</h1><h1 id="二、RDB快照"><a href="#二、RDB快照" class="headerlink" title="二、RDB快照"></a>二、RDB快照</h1><h1 id="三、混合持久化方式"><a href="#三、混合持久化方式" class="headerlink" title="三、混合持久化方式"></a>三、混合持久化方式</h1>]]></content>
      
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
