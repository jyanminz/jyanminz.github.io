<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Universal References in C++11</title>
      <link href="/2023/04/30/Universal-References-in-C-11/"/>
      <url>/2023/04/30/Universal-References-in-C-11/</url>
      
        <content type="html"><![CDATA[<blockquote><p>T&amp;&amp; Doesn’t Always Mean “Rvalue Reference<br>原文<a href="https://isocpp.org/blog/2012/11/universal-references-in-c11-scott-meyers">Universal References in C++11 – Scott Meyers</a></p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>;</span><br></pre></td></tr></table></figure><p>既然右值引用使用&amp;&amp;来声明，看起来在类型声明中只要出现&amp;&amp;就认为这是一个右值引用是非常合理的，但事实并不是这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;&amp; var1 = someWidget;      <span class="comment">// here, “&amp;&amp;” means rvalue reference</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;              <span class="comment">// here, “&amp;&amp;” does not mean rvalue reference</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">// here, “&amp;&amp;” means rvalue reference</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">// here, “&amp;&amp;”does not mean rvalue reference</span></span><br></pre></td></tr></table></figure><p>在这篇文章中，作者描述了在类型声明中&amp;&amp;的两种含义，解释了如何将其区分开来，并引入了一个新的术语以便于清晰地区分&amp;&amp;在某处的含义。区分&amp;&amp;的不同含义十分重要，如果我们一在类型声明中看到&amp;&amp;就将其当作一个右值引用，这会使我们错误理解很多基于C++11的代码。</p><p>类型声明中的&amp;&amp;有时意味着右值引用，但有时其意味着右值引用或者左值引用。在源代码中有些&amp;&amp;的真正含义或许和&amp;一样，即具有右值引用语法上的形式（&amp;&amp;）但具有左值引用的含义（&amp;）。在这种情况下的引用较于右值引用和左值引用更为灵活。举例来说，右值引用或许只能与右值绑定，左值引用除了能和左值绑定，在某些restricted circumstances下还能与右值绑定（比如说const Type &amp;）。相反的，以&amp;&amp;声明的引用可能是右值引用也可能是左值引用，这种应用可以与任何对象绑定，这种非比寻常灵活的引用值得一个自己的专属名字，作者在这里将其称之为universal reference。</p><p>当&amp;&amp;表示一个universal reference时，具体的细节十分tricky，所以在讲解之前作者先介绍了一些具体的规则，这些规则在编码时也需要我们来遵守。</p><blockquote><p>当一个variable或者parameter被声明为某种<strong>推导类型</strong>T的类型**T&amp;&amp;**，该变量或者参数是一个universal reference</p></blockquote><p>涉及类型推导的要求限制了可以找到universal reference的情况，在实操中，基本上所有的universal reference都是函数模板的参数。因为以auto声明的变量与模板中的类型推导规则基本一致，以auto声明的universal reference也可能存在。这在生产代码中并不常见，但是作者在本文将会展示一些这种代码，因为它们在示例中没有模板那么冗长。在本文的nitty gritty details部分中，作者解释了universal references可能与typedef和decltype的使用同时出现。但在我们深入了解细节之前，作者将proceed as if universal referneces只涉及函数模板参数和自动声明的变量一样</p><p><em><strong>universal references总以T&amp;&amp;的形式出现</strong></em>的这个限制比它看上去非常重要。</p><p>就像所有的引用，universal references必须被初始化，而且就是universal references的initializer决定了这到底代表了一个左值引用还是一个右值引用。</p><ol><li>如果初始化universal references的表达式是一个右值，那么universal references将变成右值引用</li><li>如果初始化universal references的表达式是一个左值，那么universal references将变成左值引用</li></ol><p>这些信息只有当你能区分左值和右值的时候才有用，这些术语的精确定义很难制定，但是在实践中，下面这些规则就够用了：</p><ol><li>如果可以对一个表达式取地址，那么这个表达式就是一个左值</li><li>如果这个表达式的类型是左值引用如T&amp;或者const T&amp;，那么这个表达式就是一个左值</li><li>否则，这个表达式就是一个右值。从概念上来说，右值通常与临时对象相对应，比如说函数返回的对象或者由隐式类型转换创建的对象都是右值。</li></ol><p>考虑下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp;&amp; var1 = someWidget;</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; var2 = var1;</span><br></pre></td></tr></table></figure><p>我们可以对var1取地址，即var1是一个左值。var2的类型声明为auto&amp;&amp;，这使得var2是一个universal reference，同时因为其使用var1（左值）来初始化，var2成为了一个左值引用。简略阅读上述代码可能让你认为var2是一个右值引用：声明中&amp;&amp;显然支持这个结论。但是因为这是一个用左值初始化的universal reference，var2就成为了一个左值引用，其效果和如下代码相同：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget&amp; var2 = var1;</span><br></pre></td></tr></table></figure><p>就像上面所说的，如果一个表达式的类型为左值引用，那么其就是一个左值。考虑下面这个例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="type">int</span>&gt; v;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; val = v[<span class="number">0</span>];               <span class="comment">// val becomes an lvalue reference (see below)</span></span><br></pre></td></tr></table></figure><p>val是一个universal reference，同时其使用v[0]来初始化，即使用<code>std::vector&lt;int&gt;::operator[]</code>调用的结果来初始化。这个函数返回一个vector中元素的左值引用。因为所有的左值引用都是左值，且这个左值被用来初始化val，val成为了一个左值引用，即使其被声明的形式看上去像一个右值引用。</p><p>之前说过，universal references在函数模板参数中最为常见，考虑下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">// “&amp;&amp;” might mean rvalue reference</span></span><br></pre></td></tr></table></figure><p>给定对f的下述调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);                           <span class="comment">// 10 is an rvalue</span></span><br></pre></td></tr></table></figure><p>param使用10来初始化，因为我们不能对10取地址，那么这是一个右值。这意味着对f的调用，param这个universal reference通过一个右值来初始化，因此param变成了一个右值引用，更具体的，int&amp;&amp;</p><p>另一方面，如果f如下调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> x = <span class="number">10</span>;</span><br><span class="line"><span class="built_in">f</span>(x);                            <span class="comment">// x is an lvalue</span></span><br></pre></td></tr></table></figure><p>此时param利用变量x来初始化，因为我们可以对x取地址，所以x是一个左值，这意味着对于f的调用中，param这个universal reference利用一个左值初始化，因此param成为了一个左值，更具体的，int&amp;。</p><p>param的类型是左值引用还是右值引用取决于当f被调用，参数的类型。有时param成为左值引用，有时其成为右值引用，param是一个真正的universal reference</p><p>记住只有在类型推导中&amp;&amp;表明一个universal reference，<strong>当没有类型推导发生时，没有universal reference</strong>，在这些情况下，使用&amp;&amp;声明的类型是一个右值引用，因此：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;               <span class="comment">// deduced parameter type ⇒ type deduction;</span></span><br><span class="line">                                 <span class="comment">// &amp;&amp; ≡ universal reference</span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);        <span class="comment">// fully specified parameter type ⇒ no type deduction;</span></span><br><span class="line">    ...                          <span class="comment">// &amp;&amp; ≡ rvalue reference</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T2&gt;</span></span><br><span class="line"><span class="function">    <span class="title">Gadget</span><span class="params">(T2&amp;&amp; rhs)</span></span>;            <span class="comment">// deduced parameter type ⇒ type deduction;</span></span><br><span class="line">    ...                          <span class="comment">// &amp;&amp; ≡ universal reference</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(Widget&amp;&amp; param)</span></span>;          <span class="comment">// fully specified parameter type ⇒ no type deduction;</span></span><br><span class="line">                                 <span class="comment">// &amp;&amp; ≡ rvalue reference</span></span><br></pre></td></tr></table></figure><blockquote><p>universal reference的声明形式必须是<code>**T&amp;&amp;**</code>，考虑下面这段代码：</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;     <span class="comment">// “&amp;&amp;” means rvalue reference</span></span><br></pre></td></tr></table></figure><p>在上述代码中，类型推导和以&amp;&amp;声明的函数类型两个条件都具备了，但是参数声明形式不是T&amp;&amp;而是std::vector<T>&amp;&amp;。结果就是，这个参数是一个普通的右值引用。</T></p><blockquote><p>universal reference只能以<code>**T&amp;&amp;**</code>形式出现</p></blockquote><p>即使是仅仅加上const限定符都会让universal reference不再是universal reference：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">const</span> T&amp;&amp; param)</span></span>;               <span class="comment">// “&amp;&amp;” means rvalue reference</span></span><br></pre></td></tr></table></figure><p>考虑下面的代码，我们可以看到<code>T&amp;&amp;</code>的形式、T是一个模板参数，但没有类型推导：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="type">void</span> <span class="built_in">push_back</span>(T&amp;&amp; x);       <span class="comment">// fully specified parameter type ⇒ no type deduction;</span></span><br><span class="line">    ...                          <span class="comment">// &amp;&amp; ≡ rvalue reference</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>在这里，T是一个模板参数，push_back接受一个<code>T&amp;&amp;</code>类型的参数，但是这个参数不是一个universal reference。为什么？</p><p>让我们看看<code>push_back</code>在类外是如何被声明的就知道为何了，假设<code>std::vector</code>的Allocator参数不存在，因为其对于接下来的讨论不相关。见下面的代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line"><span class="type">void</span> vector&lt;T&gt;::<span class="built_in">push_back</span>(T&amp;&amp; x);</span><br></pre></td></tr></table></figure><p>如果没有<code>std::vector&lt;T&gt;</code>，<code>push_back</code>无法存在。但如果我们已经有一个类<code>std::vector&lt;T&gt;</code>，那么我们就已经知道了T是什么，就没必要再去推导它了。这样就认为类型推导无需发生。</p><p>下面的例子可以帮助我们理解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;             <span class="comment">// factory function for Widget</span></span><br><span class="line">std::vector&lt;Widget&gt; vw;</span><br><span class="line">...</span><br><span class="line">Widget w;</span><br><span class="line">vw.<span class="built_in">push_back</span>(<span class="built_in">makeWidget</span>());      <span class="comment">// create Widget from factory, add it to vw</span></span><br></pre></td></tr></table></figure><p>上面对于<code>push_back</code>的使用将使得编译器为<code>std::vector&lt;Widget&gt;</code>这个类初始化一个函数。<code>push_back</code>的声明就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> std::vector&lt;Widget&gt;::<span class="built_in">push_back</span>(Widget&amp;&amp; x);</span><br></pre></td></tr></table></figure><p>一旦我们知道了类是<code>std::vector&lt;Widget&gt;</code>，<code>push_back</code>的参数就被完全确定了：Widget &amp;&amp;，在这里没有类型推导的必要。</p><p>与之相反的的<code>std::vector</code>的<code>emplace_back</code>，该函数声明如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>, <span class="keyword">class</span> <span class="title class_">Allocator</span> = allocator&lt;T&gt; &gt;</span><br><span class="line"><span class="keyword">class</span> vector &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line">    <span class="type">void</span> <span class="built_in">emplace_back</span>(Args&amp;&amp;... args); <span class="comment">// deduced parameter types ⇒ type deduction;</span></span><br><span class="line">    ...                                <span class="comment">// &amp;&amp; ≡ universal references</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到<code>emplace_back</code>的参数类型必须被推导，这个函数模板的类型Args与类模板参数T是相互独立的，即使我们已经知道了这个类是<code>std::vector&lt;Widget&gt;</code>，我们仍然需要对<code>emplace_back</code>的参数类型进行推导。参考如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span>... Args&gt;</span><br><span class="line"><span class="type">void</span> std::vector&lt;Widget&gt;::<span class="built_in">emplace_back</span>(Args&amp;&amp;... args);</span><br></pre></td></tr></table></figure><p><code>std::vector::emplace_back</code>的参数都是universal references。</p><p>最后一个必须要记住的点是：<strong>一个表达式的右值属性（rvalueness）或者左值属性（lvalueness）与其类型（type）是无关、独立的</strong>。考虑int类型，有int类型的左值（被声明为int类型的变量）和int类型的右值（如10），对于用户自定义的类型上述规则同样适用，如类Widget，一个Widget对象可以是一个左值（一个Widget变量）或者一个右值（一个由创建widget对象的工厂函数返回的对象）。</p><p>一个表达式的类型没有告诉你这到底是一个左值还是一个右值，因为：一个表达式的右值属性（rvalueness）或者左值属性（lvalueness）与其类型是无关、独立的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Widget <span class="title">makeWidget</span><span class="params">()</span></span>;                       <span class="comment">// factory function for Widget</span></span><br><span class="line"> </span><br><span class="line">Widget&amp;&amp; var1 = <span class="built_in">makeWidget</span>()               <span class="comment">// var1 is an lvalue, but</span></span><br><span class="line">                                           <span class="comment">// its type is rvalue reference (to Widget)</span></span><br><span class="line"> </span><br><span class="line">Widget var2 = <span class="built_in">static_cast</span>&lt;Widget&amp;&amp;&gt;(var1); <span class="comment">// the cast expression yields an rvalue, but</span></span><br><span class="line">                                           <span class="comment">// its type is rvalue reference  (to Widget)</span></span><br></pre></td></tr></table></figure><p>将左值变为右值的方法是使用<code>std::move</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Widget var2 = std::<span class="built_in">move</span>(var1);             <span class="comment">// equivalent to above</span></span><br></pre></td></tr></table></figure><p>有名字的变量和参数（类型是右值引用）是左值，考虑如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Widget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">Widget</span>(Widget&amp;&amp; rhs);        <span class="comment">// rhs’s type is rvalue reference,</span></span><br><span class="line">    ...                          <span class="comment">// but rhs itself is an lvalue</span></span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Gadget</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T2&gt;</span><br><span class="line">    <span class="built_in">Gadget</span>(T2&amp;&amp; rhs);            <span class="comment">// rhs is a universal reference whose type will</span></span><br><span class="line">    ...                          <span class="comment">// eventually become an rvalue reference or</span></span><br><span class="line">&#125;;                               <span class="comment">// an lvalue reference, but rhs itself is an lvalue</span></span><br></pre></td></tr></table></figure><p>在Widget的构造器中，rhs是一个右值引用，因此我们知道rhs与一个右值绑定，但是rhs本身又是一个左值，所以我们必须要将其转换回一个右值（如果我们想要利用与rhs绑定的右值的优点）。</p><p>类似的，在Gadget构造器中的rhs是一个universal reference，其可以与一个左值绑定也可以和一个右值绑定，但是无论其与什么绑定，rhs本身是一个左值。如果rhs与一个右值绑定，而我们想要利用右值带来的便利性，我们必须将其转换为一个右值，如果rhs与一个左值绑定，我们不希望其被当作一个左值对待。</p><p>与universal reference绑定对象的左值性和右值性存在模糊性是<code>std::forward</code>被应用的动机，<code>std::forward</code>接受一个universal reference并将其转换为一个右值（当表达式与一个右值绑定）。The name of the function (“<code>forward</code>”) is an acknowledgment that our desire to perform such a conversion is virtually always to <strong>preserve the calling argument’s lvalueness or rvalueness when passing</strong> – <em>forwarding</em> – it to another function.</p><h1 id="Nitty-Gritty-Details"><a href="#Nitty-Gritty-Details" class="headerlink" title="Nitty Gritty Details"></a>Nitty Gritty Details</h1><p>当模板参数为一个universal reference，在进行类型推导时：</p><ol><li>类型为T的左值被推导为T&amp;</li><li>类型为T的右值被推导为T</li></ol><p>考虑如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(T&amp;&amp; param)</span></span>;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="type">int</span> x;</span><br><span class="line"> </span><br><span class="line">...</span><br><span class="line"> </span><br><span class="line"><span class="built_in">f</span>(<span class="number">10</span>);                           <span class="comment">// invoke f on rvalue</span></span><br><span class="line"><span class="built_in">f</span>(x);                            <span class="comment">// invoke f on lvalue</span></span><br></pre></td></tr></table></figure><p>其中f(10)，T被推导为int：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">f</span><span class="params">(<span class="type">int</span>&amp;&amp; param)</span></span>;             <span class="comment">// f instantiated from rvalue</span></span><br></pre></td></tr></table></figure><p>而f(x)，T被推导为int &amp;：</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++ Rvalue References Explained</title>
      <link href="/2023/04/28/C-Rvalue-References-Explained/"/>
      <url>/2023/04/28/C-Rvalue-References-Explained/</url>
      
        <content type="html"><![CDATA[<h1 id="C-Rvalue-References-Explained"><a href="#C-Rvalue-References-Explained" class="headerlink" title="C++ Rvalue References Explained"></a><strong>C++ Rvalue References Explained</strong></h1><p>本文是对<a href="http://thbecker.net/articles/rvalue_references/section_01.html">Thomas Becker</a>的粗浅翻译，若有错误欢迎指出。</p><p>Rvalue references solve at least two problems:</p><ol><li>Implementing move semantics</li><li>Perfect forwarding</li></ol><h1 id="C-中的左值和右值"><a href="#C-中的左值和右值" class="headerlink" title="C++中的左值和右值"></a>C++中的左值和右值</h1><ol><li><p>早期在C中对lvalue和rvalue最初的定义如下：</p><ol><li><p>lvalue：一个出现在赋值符左边或者右边的expression（An <em>lvalue</em> is an expression <code>e</code> that may appear on the left or on the right hand side of an assignment）</p></li><li><p>rvalue：只出现在赋值符右边的expression（An <em>lvalue</em> is an expression <code>e</code>that may appear on the left or on the right hand side of an assignment）</p></li><li><p>举例来说：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="type">int</span> b = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a和b都是lvalues</span></span><br><span class="line">a = b;</span><br><span class="line">b = a;</span><br><span class="line">a = a * b;</span><br><span class="line"></span><br><span class="line"><span class="comment">//a * b是一个rvalue</span></span><br><span class="line"><span class="type">int</span> c = a * b;</span><br><span class="line">a * b = <span class="number">42</span><span class="comment">//false</span></span><br></pre></td></tr></table></figure></li></ol></li><li><p>在C++中，利用早期C中对于lvalue和rvalue的定义仍然有用，并且这种判断方法是一个intuitive的方法</p></li><li><p>但是在C++中，由用户定义的类型在modifiability和assignability中引入了一些微妙的变化，这些变化使得上述的定义变得不再准确。我们无需go further into this；下面是一个代替上述定义的定义，即使该定义存在一些争议，但会让读者更加容易理解rvalue references：</p><ol><li><p>lvalue即是一个expression，该expression refer to一个内存地址，并且允许我们通过&amp;来获取该内存地址的地址（An <em>lvalue</em> is an expression that refers to a memory location and allows us to take the address of that memory location via the <code>&amp;</code>operator）</p></li><li><p>rvalue即是一个expression，不是lvalue的就是rvalue（An <em>rvalue</em> is an expression that is not an lvalue）</p></li><li><p>举例来说</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lvalues:</span></span><br><span class="line"><span class="type">int</span> i = <span class="number">42</span>;</span><br><span class="line">i = <span class="number">43</span>;<span class="comment">//i is a lvalue</span></span><br><span class="line"><span class="type">int</span> *p = &amp;i;<span class="comment">//i is a lvalue</span></span><br><span class="line"><span class="function"><span class="type">int</span> &amp;<span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">foo</span>() = <span class="number">42</span>;<span class="comment">//foo() is a lvalue</span></span><br><span class="line"><span class="type">int</span> *pl = &amp;<span class="built_in">foo</span>();<span class="comment">// foo() is a lvalue</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//rvalues:</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"><span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">j = <span class="built_in">foobar</span>();<span class="comment">//foobar() is a rvalue</span></span><br><span class="line"><span class="type">int</span> *p2 = &amp;<span class="built_in">foobar</span>();<span class="comment">//error cannot take the address of a rvalue</span></span><br><span class="line">j = <span class="number">32</span>;<span class="comment">//32 is a rvalue</span></span><br></pre></td></tr></table></figure></li></ol></li></ol><h1 id="移动语义"><a href="#移动语义" class="headerlink" title="移动语义"></a>移动语义</h1><p>假设X是一个维护或者handle某些资源的类，比如说m_pResource；这里说的资源resource，作者指的是任何需要付出一定代价来construct（构建）、clone（克隆）、destruct（析构）的事物。</p><p>一个很好的例子是std::vector，一个vector在为其分配的内存中维护了一系列的对象objs。那么，逻辑上来说，对于X的copy assignment operator就会类似如下的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="type">const</span> &amp;rhs)&#123;</span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line"><span class="comment">//make a clone of what ths.m_pResource refers to</span></span><br><span class="line"><span class="comment">//destruct the resource that m_pResouce refers to</span></span><br><span class="line"><span class="comment">//attach the clone to m_pResource</span></span><br><span class="line"><span class="comment">//[...]</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于X的copy constructor，类似于上述代码中的逻辑同样适用，假设X被如下使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line">X x;</span><br><span class="line"><span class="comment">// perhaps use x in various ways</span></span><br><span class="line">x = <span class="built_in">foo</span>();</span><br></pre></td></tr></table></figure><p>上述代码中的最后一行实际上完成了如下工作：</p><ul><li>从foo中返回的临时资源中clone</li><li>destruct x持有的资源并将其用clone来代替</li><li>destruct这个临时的资源并由此释放其资源</li></ul><p>显然，如果能够在x和临时资源之间通过**swap resource pointers(handles)**，接着令临时资源的destructor来destruct x的原始资源（to swap resource pointers (handles) between <code>x</code> and the temporary, and then let the temporary’s destructor destruct <code>x</code>‘s original resource），这样的方法更为有效。换一种方式来说，当在赋值符右边是一个rvalue的特殊情况下，我们希望copy assignment operator以如下的方式运作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// [...]</span></span><br><span class="line"><span class="comment">// swap m_pResource and rhs.m_pResource</span></span><br><span class="line"><span class="comment">// [...]</span></span><br></pre></td></tr></table></figure><p>这被称为移动语义，在C++11中，这种conditional behavior可以通过一个重载来完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(&lt;mystery type&gt; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// [...]</span></span><br><span class="line">  <span class="comment">// swap this-&gt;m_pResource and rhs.m_pResource</span></span><br><span class="line">  <span class="comment">// [...]  </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>既然我们正在定义一个copy assignment operator的重载，上述代码中的mystery type必须是一个引用（we certainly want the right hand side to be passed to us by reference）</p><p>并且，我们期望mystery type具有如下的表现：</p><ol><li>当在一个使用普通引用和一个使用mystery type的两个重载中，rvalue选择mystery type的重载实现</li><li>而lvalues选择普通引用的重载实现</li></ol><p>此时，如果我们用rvalue reference来代替上述的mystery type，那么我们看到的就是关于rvalue reference的定义</p><h1 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h1><p>如果X是一个任意的类型，那么X&amp;&amp;就是一个X的右值引用，为了更好的区分，普通的引用X&amp;又被称为左值引用</p><p>右值引用在很多方面与左值引用并无二致，但其在某些方面表现不同，其中最重要的就是在函数重载中，lvalue倾向于使用lvalue references，而rvalue倾向于使用rvalue references</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp; x)</span></span>; <span class="comment">// lvalue reference overload</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>; <span class="comment">// rvalue reference overload</span></span><br><span class="line"></span><br><span class="line">X x;</span><br><span class="line"><span class="function">X <span class="title">foobar</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">foo</span>(x); <span class="comment">// argument is lvalue: calls foo(X&amp;)</span></span><br><span class="line"><span class="built_in">foo</span>(<span class="built_in">foobar</span>()); <span class="comment">// argument is rvalue: calls foo(X&amp;&amp;)</span></span><br></pre></td></tr></table></figure><p>故其主旨在于：</p><blockquote><p>Rvalue references allow a function to branch <strong>at compile time</strong> (via overload resolution) on the condition “Am I being called on an lvalue or an rvalue?”</p></blockquote><p>事实上，我们可以为任意函数重载一个使用rvalue references的定义，但是在绝大多数情况下，这种重载应该只发生在copy constructor以及assignment operator中，由此来实现移动语义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X <span class="type">const</span> &amp; rhs); <span class="comment">// classical implementation</span></span><br><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于copy constructor的右值引用重载来说，其实现与上述代码类似；</p><ul><li>注意：<ul><li>如果我们实现void foo(X &amp;)而没有实现void foo(X&amp;&amp;)，那么函数调用时没有发生变化：foo可以传入lvalues来调用，而不能通过传入rvalues来调用</li><li>如果我们实现void(X const &amp;)而没有实现void foo(X &amp;&amp;)，此时，foo可以通过传入lvalues和rvalues来调用，但是无法区分lvalues和rvalues，要想达到区分lvalues和rvalues的目的，必须实现void foo(X &amp;&amp;)</li><li>如果我们只实现void foo(X&amp;&amp;)而没有其他两个函数，那么根据C++11的最终版本，foo可以通过传入rvalues调用，但是如果传入一个lvalue将会触发编译错误</li></ul></li></ul><h1 id="Forcing-Move-Semantics"><a href="#Forcing-Move-Semantics" class="headerlink" title="Forcing Move Semantics"></a><strong>Forcing Move Semantics</strong></h1><p>C++11允许程序员在rvalues和lvalues上使用移动语义，一个很好的例子就是标准库函数中的swap；同样的，令X为一个重载了copy constructor和copy assignment operator的类，如此来完成在rvalues实现移动语义</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">T <span class="title">tmp</span><span class="params">(a)</span></span>;</span><br><span class="line">  a = b; </span><br><span class="line">  b = tmp; </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">X a, b;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure><p>上述代码中没有rvalues，因此，swap函数的三行代码中使用non-move semantic，但是我们知道在如下场景可以使用移动语义：任何时候当一个variable成为copy construction或者copy assignment的源（source），这个variable不会再被使用或者称为一个assignment的目标（wherever a variable occurs as the source of a copy construction or assignment, that variable is either not used again at all, or else it is used only as the target of an assignment.）</p><p>C++11中，存在一个标准库函数std::move，这个函数用于将其参数转换为rvalue，在C++11中，标准库函数swap看起来就像下面这样：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt; </span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">swap</span><span class="params">(T&amp; a, T&amp; b)</span> </span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">T <span class="title">tmp</span><span class="params">(std::move(a))</span></span>;</span><br><span class="line">  a = std::<span class="built_in">move</span>(b); </span><br><span class="line">  b = std::<span class="built_in">move</span>(tmp);</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">X a, b;</span><br><span class="line"><span class="built_in">swap</span>(a, b);</span><br></pre></td></tr></table></figure><p>如此一来，swap函数的三行代码中使用到了移动语义，对于没有实现移动语义的类型来说（即没有为其copy constructor和assignment operator重载右值引用的类型），这个新的swap的表现和老的swap一样。</p><p>使用std::move为我们带来了如下好处：</p><ol><li>对于哪些实现了移动语义的类型，许多标准的算法或者操作通过使用移动语义显著节省资源；一个很好的例子就是inplace sorting，在其中使用了大量的swap</li><li>STL经常需要特定类型具有copyability，即可成为容器元素的类型；但仔细审视，发现在大多数情况下，moveability已经足够。因此，我们可以使用具有moveability但非copyable的类型（如unique_pointer）</li></ol><p>既然我们已经知道了std::move的存在，我们就可以看出之前对copy assignment operator进行右值引用重载的方法存在一点问题。</p><p>考虑一个简单的变量赋值：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = b</span><br></pre></td></tr></table></figure><p>我们期望a持有的对象被一个b的拷贝取代，并且在这个取代的过程中，我们期望a之前持有的对象被析构，现在考虑下一行代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a = std::<span class="built_in">move</span>(b);</span><br></pre></td></tr></table></figure><p>如果实现移动语义仅用于一个简单的swap，那么上述代码中发生的只是：a和b交换了资源，没有任何析构发生，a之前持有的对象肯定最终会被析构，但仅仅发生在b超过其作用域。除非，b成为了move的对象，这种情况下，a之前持有的对象会继续被pass。</p><p>因此，在我们考虑的copy assignment operator的实现中，我们不知道a之前持有的对象何时会被析构（Therefore, as far as the implementer of the copy assignment operator is concerned, it is not known when the object formerly held by <code>a</code> will be destructed）</p><p>这种放任a持有对象被析构的时间可能不会出现问题（如果the destruction of that object does not have any side effects that are visible to the outside world），但我们必须考虑到意外情况，比如说在析构函数中释放一个锁呢？因此，在右值引用的重载copy assignmentoperator中关于对象的析构必须显式被调用。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">X&amp; X::<span class="keyword">operator</span>=(X&amp;&amp; rhs)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Perform a cleanup that takes care of at least those parts of the</span></span><br><span class="line">  <span class="comment">// destructor that have side effects. Be sure to leave the object</span></span><br><span class="line">  <span class="comment">// in a destructible and assignable state.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Move semantics: exchange content between this and rhs</span></span><br><span class="line">  </span><br><span class="line">  <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Is-an-Rvalue-Reference-an-Rvalue"><a href="#Is-an-Rvalue-Reference-an-Rvalue" class="headerlink" title="Is an Rvalue Reference an Rvalue?"></a><strong>Is an Rvalue Reference an Rvalue?</strong></h1><p>和之前一样，令X为一个利用移动语义重载了其copy constructor和copy assignment operator的类；考虑如下函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X &amp;&amp; x)</span></span>&#123;</span><br><span class="line">X anotherX = x;</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>有趣的问题是：在foo函数中，X的哪个版本的copy constructor会被调用？在这里，x是一个被声明为右值引用的变量，即，a reference which preferably and typically refers to an rvalue，因此，和x相关的函数调用应该和右值引用版本相关联，比如说<code>X(X&amp;&amp; rhs)</code>，换句话说，我们应该期待任何被声明为右值引用的东西本身应该是右值，右值引用的设计者应该考虑到一个细微的变化：</p><blockquote><p>任何被声明为右值引用的东西可以为lvalue或者rvalue，区分的标准是：如果这个东西有名字，那么其就是一个lvalue，否则其就是一个rvalue</p></blockquote><p>在上面的例子中，被声明为一个右值引用的东西有一个名称<code>x</code>，那么其就是一个<code>lvalue</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(X&amp;&amp; x)</span></span>&#123;</span><br><span class="line">X anotherX = x;<span class="comment">//calls X(X const &amp;rhs)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面就是一个被声明为右值引用而且没有名字，因此其是一个rvalue：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X&amp;&amp; <span class="title">goo</span><span class="params">()</span></span>;</span><br><span class="line">X x = <span class="built_in">goo</span>(); <span class="comment">// calls X(X&amp;&amp; rhs) because the thing on</span></span><br><span class="line">             <span class="comment">// the right hand side has no name</span></span><br></pre></td></tr></table></figure><p>这种设计背后的原因是：Allowing move semantics to be applied tacitly to something that has a name</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X anotherX = x;</span><br><span class="line"><span class="comment">// x is still in scope!</span></span><br></pre></td></tr></table></figure><p>像上述代码中的操作，是危险且容易招致错误的；因为我们已经移动过的东西在接下来的代码中仍然可以被访问，但是移动语义的全部要点就是：“在移动这个东西之后，dies and goes away”，因此上述规则：如果一个东西有名字，那么其就是一个左值，是合理的。</p><p>那么关于上述规则的另外一部分该如何理解呢？：如果一个东西没有名字，那么其是一个右值。</p><p>继续将目光投向上述的goo例子中，it is technically possible, though <strong>not very likely</strong>, that the expression <code>goo()</code> in the second line of the example refers to something that is still accessible after it has been moved from</p><p>但是回顾之前的section：这正是我们想要的，我们想要能够在左值上实现强制移动语义。那么这正是这条规则：如果一个obj没有名字，那么该obj就是一个右值，这条规则允许我们以可控的方式（controlled manner）实现强制移动语义，这也是std::move实现的原理（std::move将参数以引用形式引入，并没有在这个参数上进行任何的操作，然后其结果返回的类型就是一个右值引用）</p><p>该语句：std::move(x)被声明为一个右值引用而且并没有一个名字与其绑定，因此，其是一个右值。因此，std::move将其参数转换为一个右值，即使该参数本身不是一个右值。std::move实现的方式就是隐藏其名字。</p><p>下面的例子说明了“if-it-has-a-name rule”有多么重要，假设有一个基类Base，在这个基类中为copy constructor和assignment operator重载了移动语义的版本：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Base</span>(Base <span class="type">const</span> &amp; rhs); <span class="comment">// non-move semantics</span></span><br><span class="line"><span class="built_in">Base</span>(Base&amp;&amp; rhs); <span class="comment">// move semantics</span></span><br></pre></td></tr></table></figure><p>现在假设我们在Base的基础上实现了一个Derived类，为了确保移动语义在Derived对象中的Base部分被应用，我们必须重载Derived类的copy constructor和assignment operator，其中copy assignment operator的操作与上面的类似，对于左值的版本是非常直观的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived <span class="type">const</span> &amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(rhs)</span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而对于右值的版本有一点细微的不同，当我们没有意识到“if-it-has-a-name rule”时，我们可能会写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived&amp;&amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(rhs) <span class="comment">// wrong: rhs is an lvalue</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d如果我们写出像上面一样的代码，Base类中的非移动版本的copy constructor将会被调用，因为rhs是有名字的！因此，其是一个左值，但我们期望的是调用Base中移动版本的copy constructor，那么我们必须写出如下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Derived</span>(Derived&amp;&amp; rhs) </span><br><span class="line">  : <span class="built_in">Base</span>(std::<span class="built_in">move</span>(rhs)) <span class="comment">// good, calls Base(Base&amp;&amp; rhs)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">// Derived-specific stuff</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Move-Semantics-and-Compiler-Optimizations"><a href="#Move-Semantics-and-Compiler-Optimizations" class="headerlink" title="Move Semantics and Compiler Optimizations"></a><strong>Move Semantics and Compiler Optimizations</strong></h1><p>考虑如下的函数定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="comment">// perhaps do something to x</span></span><br><span class="line">  <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>d假设X是一个为copy constructor和copy assignment operator重载了移动语义版本的类，如果我们从字面意义上理解上述代码，我们或许会说，“等等，在x到foo的返回值这块存在一个value copy的动作，让我们考虑使用移动语义吧”</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  X x;</span><br><span class="line">  <span class="comment">// perhaps do something to x</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">move</span>(x); <span class="comment">// making it worse!</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但不幸的是，上述代码将make things worse。任何现代编译器将对foo的原始版本进行一个返回值优化。换言之，与其在本地构建x然后将其复制出去，编译器会在foo的返回值处直接构建x对象，显而易见，这比使用移动语义要更好。</p><p>正如你所见，为了最好地使用右值引用和移动语义，我们需要理解并考虑到现代编译器所作出的特殊努力，正如返回值优化以及copy elision。这会使得事情变得微妙起来，但是，we chose C++ as our language of choice for a reason, right? We made our beds, so now let’s lie in them.</p><h1 id="Perfect-Forwarding-The-Problem"><a href="#Perfect-Forwarding-The-Problem" class="headerlink" title="Perfect Forwarding: The Problem"></a><strong>Perfect Forwarding: The Problem</strong></h1><p>考虑下面这个简单的工厂函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>显而易见，该函数的意图是转发（forward）参数arg到T的构造函数中；理想来说，这个函数的工作方式应该就好像这个工厂函数并不存在，参数直接被转发到了构造函数中：即perfect forwarding。难过的是，上述代码完全不能胜任这个工作：其引入了一个新的面向值的调用（it introduces an extra call by value），当构造函数的参数为引用形式时，上述代码显得尤为拉跨。</p><p>最常见的解决方式是：选择如Boost::bind或者其他outer function，将参数修改为引用的形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码有些许改进，但是并非完美。现在问题变为：该工厂函数无法通过右值被调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">factory</span>&lt;X&gt;(<span class="built_in">hoo</span>()); <span class="comment">// error if hoo returns by value</span></span><br><span class="line"><span class="built_in">factory</span>&lt;X&gt;(<span class="number">41</span>); <span class="comment">// error</span></span><br></pre></td></tr></table></figure><p>这可以通过将参数属性修改为const引用来改进：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg <span class="type">const</span> &amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(arg));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式存在两个问题：</p><ol><li>如果factory并非只有一个，而是含有多个参数，我们必须提供不同参数所有non-const和const引用的组合数目个重载</li><li>这种转发并非完美，因为其避开了移动语义：在factory函数体中T的构造函数的参数是一个左值；因此，移动语义基本上不会发生（即使有可能没有这个包装函数，并且直接调用可能利用到移动语义）</li></ol><p>事实上，右值引用可以用来解决上述两个问题。右值引用为实现完美转发而不是使用非常多的重载成为可能。</p><h1 id="Perfect-Forwarding-The-Solution"><a href="#Perfect-Forwarding-The-Solution" class="headerlink" title="Perfect Forwarding: The Solution"></a><strong>Perfect Forwarding: The Solution</strong></h1><p>为了理解右值引用如何实现完美转发，我们需要先介绍两条新的关于右值引用的规则。</p><ol><li><p>记得在pre-11 C++中的语法规则中，我们无法在引用上取引用：类似于A&amp; &amp;这样的调用会造成编译错误，而C++11引入了如下的<code>**reference collapsing rules**</code>：</p><ol><li>A&amp; &amp; becomes A&amp;</li><li>A&amp; &amp;&amp; becomes A&amp;</li><li>A&amp;&amp; &amp; becomes A&amp;</li><li>A&amp;&amp; &amp;&amp; becomes A&amp;&amp;</li></ol></li><li><p>对于接收右值引用作为template argument的函数模板，存在一种特殊的模板参数推断规则：</p> <figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">foo</span><span class="params">(T&amp;&amp;)</span></span>;</span><br></pre></td></tr></table></figure><p> 对于上述代码来说适用下列的规则：</p><ol><li>当foo在一个类型为<strong>A的左值</strong>上被调用，**T被解析为A&amp;**，从而根据reference collapsing rule，参数类型将变为A&amp;</li><li>当foo在一个类型为<strong>A的右值</strong>上被调用，<strong>T被解析为A</strong>，从而根据reference collapsing rule，参数类型将变为A&amp;&amp;</li></ol></li></ol><p>基于上述两条规则，我们现在可以适用右值引用来解决之前提到的完美转发的问题，解决方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> Arg&gt; </span></span><br><span class="line"><span class="function">shared_ptr&lt;T&gt; <span class="title">factory</span><span class="params">(Arg&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;T&gt;(<span class="keyword">new</span> <span class="built_in">T</span>(std::forward&lt;Arg&gt;(arg)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码中的std::forward定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> S&gt;</span></span><br><span class="line"><span class="function">S&amp;&amp; <span class="title">forward</span><span class="params">(<span class="keyword">typename</span> remove_reference&lt;S&gt;::type&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;S&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面将从左值和右值两个方面来探讨上面的代码如何实现完美转发，令A和X为不同的类型。</p><p>首先假设，factory<A>在一个类型为X 的左值上被调用：</A></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line"><span class="built_in">factory</span>&lt;A&gt;(x);</span><br></pre></td></tr></table></figure><p>接着，基于special template deduction规则，factory的模板参数Arg被解析为X&amp;，因此，编译器会为factory和std::forward创建如下的实例（instantiation）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp; &amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&amp;&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp; &amp;&amp; <span class="title">forward</span><span class="params">(remove_reference&lt;X&amp;&gt;::type&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp; &amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在evaluate remove_reference和应用reference collapsing规则之后，上述代码将变成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&amp;&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp; <span class="title">std::forward</span><span class="params">(X&amp; a)</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是对于左值的完美转发，factory的参数arg通过两层indirection传入到A的构造器中，两层都是通过old-fashioned左值引用</p><p>接下来，假设factory<A>在类型为X的右值上被调用：</A></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X <span class="title">foo</span><span class="params">()</span></span>;</span><br><span class="line"><span class="built_in">factory</span>&lt;A&gt;(<span class="built_in">foo</span>());</span><br></pre></td></tr></table></figure><p>类似的，通过special template deduction规则，factory的模板参数Arg被解析为X。由此，编译器会创建如下的两个实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">shared_ptr&lt;A&gt; <span class="title">factory</span><span class="params">(X&amp;&amp; arg)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">shared_ptr</span>&lt;A&gt;(<span class="keyword">new</span> <span class="built_in">A</span>(std::forward&lt;X&gt;(arg)));</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function">X&amp;&amp; <span class="title">forward</span><span class="params">(X&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这正是右值的完美转发：factory的参数经过两层转发最终传入到A的构造器中，两层转发都是经过引用。而且，A的构造器看到的参数是一个右值引用而且并没有和一个名字绑定（does not have a name），基于no-name规则，这样的东西是一个右值。因此，A的构造器将通过一个右值来调用。这意味着转发保留了所有的移动语义，就像factory wrapper不存在时一样。</p><p>值得提一嘴的是，std::forward存在的唯一目的就是为了保留移动语义（the preservation of move semantics is in fact the <em>only</em> purpose of <code>std::forward</code> in this context）如果不使用std::forward，除了A的构造器将永远将其参数视为一个有名字的左值，函数其他功能还是能够正常的工作。</p><p>另一种说法是std::forward的目的就是：to forward the information whether at the call site, the wrapper saw an lvalue or an rvalue.</p><p>如果想要再深挖一点，问问自己这个问题：在std::forward的定义中，remove_reference为何会存在？答案是：remove_reference可以不被需要，如果我们在std::forward定义中使用S&amp;而不是remove_reference<S>::type&amp;，我们可以得到上述一样的结果。但是，<strong>只有当我们显式地specify Arg作为std::forwad的模板参数才能达到上述结果</strong>。remove_reference的目的就在于强迫我们这样做。</S></p><p>高兴的是，我们就快结束了。剩下的仅是看看std::move的实现。记住，std::move的目的在于：pass its argument right through by reference and make it bind like an rvalue</p><p>下面是std::move的实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt; </span><br><span class="line"><span class="keyword">typename</span> remove_reference&lt;T&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">std::move</span><span class="params">(T&amp;&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;T&gt;::type&amp;&amp; RvalRef;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;RvalRef&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设我们通过类型为X的左值调用std::move</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">X x;</span><br><span class="line">std::<span class="built_in">move</span>(x);</span><br></pre></td></tr></table></figure><p>基于special template deduction规则，模板参数T将会被解析为X&amp;，因此，编译器会生成如下实例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typename</span> remove_reference&lt;X&amp;&gt;::<span class="function">type&amp;&amp;</span></span><br><span class="line"><span class="function"><span class="title">std::move</span><span class="params">(X&amp; &amp;&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">typedef</span> <span class="keyword">typename</span> remove_reference&lt;X&amp;&gt;::type&amp;&amp; RvalRef;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;RvalRef&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在应用remove_reference和reference collapsing规则之后，上述代码将变为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">X&amp;&amp; <span class="title">std::move</span><span class="params">(X&amp; a)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">static_cast</span>&lt;X&amp;&amp;&gt;(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>S上述代码完成了如下任务：左值x将会与左值引用绑定作为其参数类型（our lvalue <code>x</code> will bind to the lvalue reference that is the argument type），函数将这个参数pass right through，将其转换为一个没有名字的右值引用。</p><h1 id="Rvalue-References-And-Exceptions"><a href="#Rvalue-References-And-Exceptions" class="headerlink" title="Rvalue References And Exceptions"></a><strong>Rvalue References And Exceptions</strong></h1><p>正常来说，当你正在开发一款基于C++的应用，是否关注程序的异常安全性完全取决于你的选择。右值引用在异常安全的语境下又存在一些不同，当你想要利用移动语义重载一个类中的copy assignment operator和copy constructor，下面几件工作是非常建议你完成的：</p><ol><li>尽量写出不抛出异常的重载代码</li><li>如果能够写出不抛出异常的代码，接下来就使用nonexcept关键字</li></ol><p>如果你没有完成上述两件工作，那么至少存在一个非常常见的场景，该场景下移动语义不会生效（尽管你非常期望移动语义能够生效）：当std::vector进行resize时，你当然希望vector中现存的元素被relocate进新的内存块时使用移动语义，但是如果上述两个条件没有满足，这种事情不会发生。</p><h1 id="The-Case-of-the-Implicit-Move"><a href="#The-Case-of-the-Implicit-Move" class="headerlink" title="The Case of the Implicit Move"></a><strong>The Case of the Implicit Move</strong></h1><p>当用户没有提供为右值引用重载的拷贝构造函数或者重载赋值操作符时，编译器将implicitly生成这两个重载的函数。这将导致一些问题，具体参见：<a href="http://thbecker.net/articles/rvalue_references/section_10.html">http://thbecker.net/articles/rvalue_references&#x2F;section_10.html</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CMU15445 PROJECT1 BUFFER POOL</title>
      <link href="/2023/04/17/CMU15445-PROJECT-1-BUFFER-POOL/"/>
      <url>/2023/04/17/CMU15445-PROJECT-1-BUFFER-POOL/</url>
      
        <content type="html"><![CDATA[<h1 id="Project-1-Buffer-Pool"><a href="#Project-1-Buffer-Pool" class="headerlink" title="Project#1-Buffer Pool"></a>Project#1-Buffer Pool</h1><p>project1要求实现一个线程安全的缓冲池，该缓冲池用于在内存和磁盘中实现数据页的来回移动，缓冲池的存在允许DBMS管理大小大于系统中可用内存的数据库。并且，缓冲池的各种操作对于数据库系统的其他部分是透明的。</p><p>下文首先对完成proj1必要的背景知识进行介绍，随之介绍各子任务的实现细节。</p><h1 id="一、Buffer-Manager"><a href="#一、Buffer-Manager" class="headerlink" title="一、Buffer Manager"></a>一、Buffer Manager</h1><p>首先，缓冲池就是在系统内存中开辟的一块用于保存磁盘数据副本的空间，这些副本较于磁盘数据往往更加“新”（被修改过）或者和磁盘数据一致，被修改过的内存数据之后会被写入磁盘中。</p><p>由于数据库的数据想要被读取或者被更新，首先要被读入系统内存中，因为磁盘访问速度远远小于内存的访问速度以及将数据库所有数据全部加载进内存是不可能的。当某线程想要访问数据库中的某个数据块时，如何减少磁盘的直接访问从而提高访问效率是一个值得探讨的问题。</p><p>缓冲池管理器(buffer pool manager)的存在就是为了最大化当线程想要访问某一数据块时，该数据块在内存中而不是磁盘中的概率，即减少对磁盘的直接访问。当某一线程对BPM发送对磁盘中的某数据块的请求：</p><ol><li>如果该数据块在缓冲池中，那么BPM将返回该数据块在内存中的地址。</li><li>如果该数据块不在缓冲池中，那么BPM首先在缓冲池中为该数据块分配相应大小的空间，这里又可以分为两个情况：<ol><li>缓冲池中空余空间大于数据块需要的空间，那么直接分配即可；</li><li>缓冲池中空余空间小于数据块需要的空间，那么BPM首先会驱逐池中的某些数据块，再进行空间的分配。如果这些数据块在加载进缓冲池中后被修改过，那么在驱逐它们之前需要将这些数据重写回磁盘。</li></ol></li></ol><p>可以看到BPM扮演的角色和虚拟内存管理器(Virtual memory manager)比较相似，但是相较于VMM，BPM的实现使用了更加精细复杂的技巧。</p><h1 id="二、Buffer-replacement-strategy"><a href="#二、Buffer-replacement-strategy" class="headerlink" title="二、Buffer replacement strategy"></a>二、Buffer replacement strategy</h1><p>当内存中没有剩余空间为新的数据块请求分配时，现存于缓冲池的某些数据块必须被驱逐，大多数操作系统使用LRU来管理数据块的驱逐。在对数据块进行驱逐出和写进来缓冲池时，需要注意以下几个方法的实现：</p><h3 id="2-1-pinned-blocks"><a href="#2-1-pinned-blocks" class="headerlink" title="2.1 pinned blocks"></a>2.1 pinned blocks</h3><p>当一个数据块被放入缓冲池后，而此时某一线程正在读取或者写入该数据页，如果这时有其他的线程将该数据块驱逐出缓冲池并且在该地址替换了一个新的数据页，这必然会出现问题。</p><p>那么为了保证正在被使用的数据页不被驱逐，就需要对该数据页打上一个标记，也就是子标题的pin这个数据页。当线程在某个数据页上执行pin操作，这个数据页在结束线程对其访问之前不会被驱逐。当线程执行完对该数据页的操作时，线程应当在该数据页上执行unpin操作，表明自己已经结束对该数据页的使用，同时表明该数据页此时可以被驱逐。</p><p>在多线程环境下，可能有多个线程对同一个数据页进行访问，那么只有当所有线程都结束了对该数据页的访问时，该数据页才能被驱逐。一个简单的实现是对缓冲池中的每一个数据页都维护一个pin_count的变量：</p><ol><li>当数据页被pin时，pin_count+1；</li><li>当数据页被unpin时，pin_count-1；</li><li>当pin_count为0时，表明其可以被驱逐出缓冲池。</li></ol><h3 id="2-2-shared-and-exclusive-locks-on-buffer"><a href="#2-2-shared-and-exclusive-locks-on-buffer" class="headerlink" title="2.2 shared and exclusive locks on buffer"></a>2.2 shared and exclusive locks on buffer</h3><p>BMP允许线程在缓冲池中拿到共享或独占锁。即当线程在某个数据页上执行变更其内容的操作时，其他线程是不能访问该数据页的内容的。其中对于上锁有如下规定：</p><ol><li>共享锁在同一时间可以被多个线程获取；</li><li>独占锁在某一时间只有一个线程能够被获取，在数据页被加上独占锁后，是不能够再加共享锁的；</li><li>当数据页被加上独占锁a或者共享锁a后，如果其余线程想要获取该数据页的独占锁b，必须等待独占锁a&#x2F;共享锁a解锁；</li><li>当数据页被加上独占锁，对该页共享锁的申请页必须等待。</li></ol><p>获取锁和释放锁的规定：</p><ol><li>当线程对某一数据页执行任何操作时，线程必须执行pin操作而后上锁，在结束对该数据页的操作后，先释放锁而后执行unpin操作；</li><li>在读取缓冲池中数据页之前，线程必须获得该数据页的共享锁，完成读取后释放之；</li><li>在更新数据页内容之前，线程必须获取该数据页的独占锁，当更新操作完成之后必须释放之。</li></ol><h1 id="三、PROJECT-1-BUFFER-POOL"><a href="#三、PROJECT-1-BUFFER-POOL" class="headerlink" title="三、PROJECT #1 - BUFFER POOL"></a>三、PROJECT #1 - BUFFER POOL</h1><h3 id="3-1-TASK-1-LRU-REPLACEMENT-POLICY"><a href="#3-1-TASK-1-LRU-REPLACEMENT-POLICY" class="headerlink" title="3.1 TASK #1 - LRU REPLACEMENT POLICY"></a>3.1 <strong><strong>TASK #1 - LRU REPLACEMENT POLICY</strong></strong></h3><p>该部分负责追踪缓冲池中页面使用的情况，主要实现lru_replacer.h中LRUReplacer类中的四个接口：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">LRUReplacer</span> : <span class="keyword">public</span> Replacer &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">LRUReplacer</span><span class="params">(<span class="type">size_t</span> num_pages)</span></span>;</span><br><span class="line">  ~<span class="built_in">LRUReplacer</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">Victim</span><span class="params">(<span class="type">frame_id_t</span> *frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Pin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">Unpin</span><span class="params">(<span class="type">frame_id_t</span> frame_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">Size</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::unordered_map&lt;<span class="type">frame_id_t</span>, std::list&lt;<span class="type">frame_id_t</span>&gt;::iterator&gt; _data_idx;</span><br><span class="line">  std::list&lt;<span class="type">frame_id_t</span>&gt; _data;</span><br><span class="line">  std::mutex _latch;</span><br><span class="line">  <span class="type">size_t</span> _max_pages;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>其中关键实现逻辑如下：</p><ol><li>Pin表示当前有线程正在访问该frame，如何确保该frame不被驱逐，最简单的方式就是将其从replacer中移除；</li><li>Unpin表示没有线程在访问该frame，表示这个frame可以成为Victim并且被驱逐，将这个frame放入replacer中即可；</li><li>Victim表示移除replacer中最不常使用的页面，其参数是一个传出参数，用于保存被驱逐出的页面的信息，当replacer为空时返回false；</li><li>LRU的实现逻辑就是：_data和_data_idx保存的是最不常被访问的数据页，当有数据页被Pin即被访问，就将其驱逐出replacer中；当数据页被Unpin，表明没有线程方位该数据页，那么就将该frame加入链表的末尾；可以看到，这样的实现保证了最不常被访问（即停留在_data链表中最久）的数据页id在链表头部，所以Victim一个数据页时就将_data头部的数据驱逐出链表即可。</li><li>注意在各种操作之前加锁；</li></ol><h3 id="3-2-TASK-2-BUFFER-POOL-MANAGER-INSTANCE"><a href="#3-2-TASK-2-BUFFER-POOL-MANAGER-INSTANCE" class="headerlink" title="3.2 TASK #2 - BUFFER POOL MANAGER INSTANCE"></a>3.2 <strong><strong>TASK #2 - BUFFER POOL MANAGER INSTANCE</strong></strong></h3><p>BufferPoolManagerInstance负责从DiskManager中提取页，并将其放入内存中。BPMI还可以将脏页写回磁盘、驱逐一个页以为新页挪出空间。该task主要实现buffer_pool_manager_instance.h中的接口，该类的主要数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Page *pages_; <span class="comment">//一个page数组用于保存缓冲池中的page</span></span><br><span class="line">std::unordered_map&lt;<span class="type">page_id_t</span>, <span class="type">frame_id_t</span>&gt; page_table_; <span class="comment">//用于管理缓冲池中的page，实现page_id到frame_id的映射</span></span><br><span class="line">Replacer *replacer_; <span class="comment">//用于找到unpined数据页</span></span><br><span class="line">std::list&lt;<span class="type">frame_id_t</span>&gt; free_list_; <span class="comment">//没有使用的page</span></span><br><span class="line">std::mutex latch_;</span><br></pre></td></tr></table></figure><p>其中frame_id就是page_id在缓冲池中的一个表现形式，数据页在DiskManager中使用page_id来管理，当被放入缓冲池中，就用frame_id来管理。bufferPool中已经对其维护的page数组进行了初始化，其后的操作都只是修改page的元数据和数据而不是消除或者新建一个page对象。我认为对frame_id和page_id的理解是完成该task的关键所在。</p><ol><li>在Page类中主要维护了pin_count用于追踪正在访问该页线程的个数、is_dirty_记录自页面放入内存池中有未被修改、page_id_时DiskManager中该页面的id，如果该页面不包含physical page则设置其为INVALID_PAGE_ID</li><li>DiskManager主要实现了将数据写入磁盘和从磁盘读取数据的一些接口。</li></ol><p><img src="/.com//Untitled.png" alt="test"></p><p>以下是BufferPoolManagerInstance中各接口的关键实现逻辑：</p><ol><li><code>FlushPgImp</code>：刷新缓冲区的指定页到磁盘中，首先检查page_table_中是否有该页，没有返回false；有则记得先将page中is_dirty_设置为false，随后调用disk_manager的函数将数据页写回到磁盘中；</li><li><code>FlushAllPgImp</code>：将每个页都写回到磁盘中；</li><li><code>NewImp</code>：在缓冲池中新建一个页<ol><li>首先检查缓冲池中的所有数据页是否都正在被使用，是则返回nullptr；</li><li>完成上述检查：首先检查free_list，free_list为空就使用replacer进行数据页的驱逐，如果二者皆失败则返回nullptr。</li><li>拿到数据页后记得检查该页是否为脏页，是则先将其写回磁盘。</li><li>接着就是将该数据页纳入page_table_的管理（这里page_id的设置有些绕，确保在page_table_中的page_id是最新的page_id）</li><li>最后记得pin该数据页；</li></ol></li><li><code>FetchPgImp</code>：获取指定数据页<ol><li>如果要fetch的数据页已经在缓冲池中，取出就好，记得将pin_count加一；</li><li>如果指定数据页不在缓冲池中，则先将该页从磁盘读入内存中，读入的过程也是先检查free_list是否有空余位置，没有再用replacer驱逐页。</li><li>拿到数据页后更新page_table_和pages中的信息以及pin该数据页</li></ol></li><li><code>UnpinPgImp</code>：用户向缓冲池通知页面使用完毕的接口<ol><li>实现上注意检查page的pin_count，pin_count为0时从replacer中unpin该page</li><li>注意在replacer和BMPI中pin&#x2F;unpin操作含义的不同：在replacer中pin一个page表示该page应该从replacer中被驱逐，而在BMPI中pin一个page表示该页正在被使用，其不能被驱逐出缓冲池。</li></ol></li></ol><h3 id="3-3-TASK-3-PARALLEL-BUFFER-POOL-MANAGER"><a href="#3-3-TASK-3-PARALLEL-BUFFER-POOL-MANAGER" class="headerlink" title="3.3 TASK #3 - PARALLEL BUFFER POOL MANAGER"></a>3.3 <strong><strong>TASK #3 - PARALLEL BUFFER POOL MANAGER</strong></strong></h3><p><code>ParallelBufferPoolManager</code>中维护了多个<code>BufferPoolManagerInstance</code>，对于每个操作，PBPM会挑选一个BPMI来完成相应任务。</p><p>在实现中使用给定的<code>page_id</code>来决定选取特定的BPMI来完成任务。比如说一共有<code>num_instances</code>个BPMI，那我们就需要将给定的page_id映射到<code>[0, num_instances)</code>这个范围中来，在该project中使用了mod算子来完成这个映射任务：<code>page_id mod num_instances</code></p><p>ParallelBufferPoolManager类中维护的关键数据结构如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ParallelBufferPoolManager</span> : <span class="keyword">public</span> BufferPoolManager &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager,</span><br><span class="line">                            LogManager *log_manager = <span class="literal">nullptr</span>);</span><br><span class="line">  ~<span class="built_in">ParallelBufferPoolManager</span>() <span class="keyword">override</span>;</span><br><span class="line">  <span class="function"><span class="type">size_t</span> <span class="title">GetPoolSize</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function">BufferPoolManager *<span class="title">GetBufferPoolManager</span><span class="params">(<span class="type">page_id_t</span> page_id)</span></span>;</span><br><span class="line">  <span class="function">Page *<span class="title">FetchPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">UnpinPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id, <span class="type">bool</span> is_dirty)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">FlushPgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function">Page *<span class="title">NewPgImp</span><span class="params">(<span class="type">page_id_t</span> *page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">bool</span> <span class="title">DeletePgImp</span><span class="params">(<span class="type">page_id_t</span> page_id)</span> <span class="keyword">override</span></span>;</span><br><span class="line">  <span class="function"><span class="type">void</span> <span class="title">FlushAllPgsImp</span><span class="params">()</span> <span class="keyword">override</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  std::vector&lt;BufferPoolManager *&gt; instances_;</span><br><span class="line">  <span class="type">size_t</span> start_idx_&#123;<span class="number">0</span>&#125;;</span><br><span class="line">  <span class="type">size_t</span> num_instances_;</span><br><span class="line">  <span class="type">size_t</span> pool_size_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>注意用于维护多个缓冲池的数据结构instances_中存放的是缓冲池实现类的基指针，接下来调用的函数应该为缓冲池实现类的基类对应的虚函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ParallelBufferPoolManager::<span class="built_in">ParallelBufferPoolManager</span>(<span class="type">size_t</span> num_instances, <span class="type">size_t</span> pool_size, DiskManager *disk_manager, LogManager *log_manager) : <span class="built_in">num_instances_</span>(num_instances), <span class="built_in">pool_size_</span>(pool_size)&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; num_instances_; i++)&#123;</span><br><span class="line">    BufferPoolManagerInstance *temp = <span class="keyword">new</span> <span class="built_in">BufferPoolManagerInstance</span>(pool_size, num_instances, i, disk_manager, log_manager);</span><br><span class="line">    instances_.<span class="built_in">push_back</span>(temp);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以下是ParallelBufferPoolManager中各接口的关键实现逻辑：</p><ol><li><code>GetBufferPoolManager</code>：<ol><li>从instances_中取出一个BPMI，下标就是用mod算子将给定page_id映射到<code>[0, num_instances_)</code>中的某个数字</li></ol></li><li><code>FetchPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的FetchPage方法</li></ol></li><li><code>UnpinPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的UnpinPage方法</li></ol></li><li><code>FlushPgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的FlushPage方法</li></ol></li><li><code>NewPgImp</code>：<ol><li>从start_idx开始，不停轮询instances中的各BMPI，看能否申请到一个新页</li><li>如果成功申请到新页，更新start_idx的值为申请到页面的下一个页面对应的BMPI的index，并返回指向该页的指针</li><li>未能成功申请到page时返回nullptr，start_idx加一</li></ol></li><li><code>DeletePgImp</code>：<ol><li>获取到给定的BMPI后，调用instance中的DeletePgImp方法</li></ol></li><li><code>FlushAllPagesImpl</code>：<ol><li>对于instances_中维护的每一个BMPI，都调用FlushAllPages方法</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> course projects </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis Cheatsheet</title>
      <link href="/2023/04/08/Redis-Cheatsheet/"/>
      <url>/2023/04/08/Redis-Cheatsheet/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis持久化</title>
      <link href="/2023/04/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96/"/>
      <url>/2023/04/07/Redis%E6%8C%81%E4%B9%85%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="Redis三种数据持久化方式"><a href="#Redis三种数据持久化方式" class="headerlink" title="Redis三种数据持久化方式"></a>Redis三种数据持久化方式</h1><h1 id="一、AOF日志"><a href="#一、AOF日志" class="headerlink" title="一、AOF日志"></a>一、AOF日志</h1><h1 id="二、RDB快照"><a href="#二、RDB快照" class="headerlink" title="二、RDB快照"></a>二、RDB快照</h1><h1 id="三、混合持久化方式"><a href="#三、混合持久化方式" class="headerlink" title="三、混合持久化方式"></a>三、混合持久化方式</h1>]]></content>
      
      
      <categories>
          
          <category> DBMS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
